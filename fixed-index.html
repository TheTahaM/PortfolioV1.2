<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>T's Website v1</title>
    <link href='https://fonts.googleapis.com/css?family=Italianno' rel='stylesheet'>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow-x: hidden;
            scroll-behavior: smooth;
        }
        body {
            background: #000000;
            height: 200vh;
        }
        
        canvas {
            position: fixed; /* Ensure canvas is fixed */
            left: 0;
            top: 0;
            width: 100%; /* Changed from width: 100% */
            height: 100vh; /* Changed from height: auto to 100vh */
            z-index: 1; /* Ensure canvas is below the top bar */
            object-fit: cover; /* Ensure proper scaling */
        }
        #topBar {
            font-family: 'Trebuchet MS', sans-serif; /* Set font to Trebuchet MS */
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 50px; /* Height of the top bar */
            background-color: rgba(0, 0, 0, 0.7); /* Semi-transparent background */
            color: rgba(255, 255, 255, 0.225);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.3s ease;
            z-index: 100; /* Ensure it is above other elements */
            backdrop-filter: blur(10px); /* Apply blur effect */
        }
        .blur {
            background-color: rgba(0, 0, 0, 0.7); /* Darker semi-transparent background */
            backdrop-filter: blur(10px); /* Apply blur effect */
        }

        /* Loading Screen */
        #loadingScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000000;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            font-family: 'Trebuchet MS', sans-serif;
            color: white;
        }

        .loading-content {
            text-align: center;
        }

        .progress-bar {
            width: 300px;
            height: 4px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
            overflow: hidden;
            margin: 20px auto;
        }

        .progress-fill {
            height: 100%;
            background: rgba(255, 255, 255, 0.6);
            width: 0%;
            transition: width 0.3s ease;
        }

        .loading-stats {
            font-size: 14px;
            color: rgba(255, 255, 255, 0.6);
        }
    </style>
</head>
<body>
    <!-- Loading Screen -->
    <div id="loadingScreen">
        <div class="loading-content">
            <h2>Loading Animation</h2>
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
            <div class="loading-stats">
                <span id="loadedCount">0</span> / <span id="totalCount">143</span> frames loaded
            </div>
        </div>
    </div>

    <div id="topBar">
        <a href="/index.html" aria-label="Go to Home" style="color: rgba(255, 255, 255, 0.577); margin: 0 15px; text-decoration: none;">Home</a> <!-- Updated link -->
        <a href="/about.html" aria-label="Learn more about me" style="color: rgba(255, 255, 255, 0.577); margin: 0 15px; text-decoration: none;">About</a> <!-- Updated link -->
        <a href="/store.html" aria-label="Visit my Store" style="color: rgba(255, 255, 255, 0.577); margin: 0 15px; text-decoration: none;">Store</a> <!-- Updated link -->
    </div> <!-- New top bar -->
    <canvas id="canvas"></canvas>
    <div id="overlay" style="position: fixed; top: 30%; left: 50%; transform: translate(-50%, -50%); color: white; font-size: 160px; transition: opacity 0.1s; opacity: 1; z-index: 10;">
        Taha's Pen
    </div>
    <!-- New message to display at the bottom -->
    <div id="endMessage" style="display: none; text-align: center; color: rgba(255, 255, 255, 0.465); font-size: 18px; position: fixed; bottom: 20px; width: 100%; z-index: 200; font-family: 'Trebuchet MS', sans-serif;">
        FIN. (this is version 1.0 mobile version coming soon) <br>
        Find out more at the <a href="store.html" style="color: rgba(255, 255, 255, 0.172); text-decoration: underline;">store</a> or learn<a href="/about.html" aria-label="Learn more about me" style="color: rgba(255, 255, 255, 0.172); text-decoration: underline;"> about</a> me
    </div>
    <script>
        console.log('Script started');
        const canvas = document.getElementById('canvas');
        const context = canvas.getContext("2d");
        
        // Enhanced image smoothing for high quality
        context.imageSmoothingEnabled = true;
        context.imageSmoothingQuality = 'high';
        
        const currentFrame = index => `./not4k/${index.toString().padStart(4, '0')}.webp`;
        const frameCount = 143;
        const html = document.documentElement;
        let currentFrameIndex = 1;

        // Image cache and loading state
        const imageCache = new Map();
        const loadingPromises = new Map();
        let imagesLoaded = 0;
        let isLoading = true;

        // Loading UI elements
        const loadingScreen = document.getElementById('loadingScreen');
        const progressFill = document.getElementById('progressFill');
        const loadedCount = document.getElementById('loadedCount');
        const totalCount = document.getElementById('totalCount');

        // Set total count
        totalCount.textContent = frameCount;

        // Configuration
        const config = {
            totalFrames: frameCount,
            preloadBatch: 20
        };

        const loadImage = (index) => {
            if (imageCache.has(index)) {
                return Promise.resolve(imageCache.get(index));
            }

            if (loadingPromises.has(index)) {
                return loadingPromises.get(index);
            }

            const promise = new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => {
                    imageCache.set(index, img);
                    imagesLoaded++;
                    updateLoadingProgress();
                    resolve(img);
                };
                img.onerror = () => {
                    console.error(`Failed to load image: ${currentFrame(index)}`);
                    reject(new Error(`Failed to load image: ${currentFrame(index)}`));
                };
                img.src = currentFrame(index);
            });

            loadingPromises.set(index, promise);
            return promise;
        };

        const updateLoadingProgress = () => {
            const progress = (imagesLoaded / frameCount) * 100;
            progressFill.style.width = progress + '%';
            loadedCount.textContent = imagesLoaded;

            if (imagesLoaded >= frameCount * 0.3 && isLoading) { // Start when 30% loaded
                isLoading = false;
                startAnimation();
                hideLoadingScreen();
            }
        };

        const hideLoadingScreen = () => {
            loadingScreen.style.opacity = '0';
            setTimeout(() => {
                loadingScreen.style.display = 'none';
            }, 500);
        };

        // USER PROVIDED METHOD - Enhanced startImageLoading
        async startImageLoading() {
            try {
                console.log('Starting to load images from not4k folder...');
                
                // Load images in batches for better performance
                const batchSize = config.preloadBatch;
                const totalBatches = Math.ceil(config.totalFrames / batchSize);
                
                for (let batch = 0; batch < totalBatches; batch++) {
                    const startFrame = batch * batchSize + 1;
                    const endFrame = Math.min(startFrame + batchSize - 1, config.totalFrames);
                    
                    console.log(`Loading batch ${batch + 1}/${totalBatches}: frames ${startFrame}-${endFrame}`);
                    
                    // Load images in parallel within each batch
                    const batchPromises = [];
                    for (let frame = startFrame; frame <= endFrame; frame++) {
                        batchPromises.push(loadImage(frame));
                    }
                    
                    // Wait for current batch to complete
                    await Promise.allSettled(batchPromises);
                    
                    // Small delay between batches to prevent overwhelming the browser
                    if (batch < totalBatches - 1) {
                        await new Promise(resolve => setTimeout(resolve, 50));
                    }
                }
                
                console.log(`Finished loading ${imagesLoaded} images`);
                isLoading = false;
                startAnimation();
                
            } catch (error) {
                console.error('Error during loading:', error);
                startAnimationFallback();
            }
        }

        const startAnimation = () => {
            console.log('Animation started');
            hideLoadingScreen();
            updateImage(currentFrameIndex);
        };

        const startAnimationFallback = () => {
            console.log('Starting animation with fallback');
            hideLoadingScreen();
            // Continue with whatever images are loaded
        };

        const updateImage = async (index) => {
            try {
                const img = await loadImage(index);
                drawImageCovered(img, context, canvas.width, canvas.height);
                currentFrameIndex = index;
            } catch (error) {
                console.error('Error updating image:', error);
            }
        };

        function drawImageCovered(img, ctx, canvas_width, canvas_height) {
            const imgRatio = img.width / img.height;
            const canvasRatio = canvas_width / canvas_height;
            let drawWidth, drawHeight, offsetX, offsetY;
            
            if (imgRatio > canvasRatio) {
                drawHeight = canvas_height;
                drawWidth = img.width * (canvas_height / img.height);
                offsetX = (canvas_width - drawWidth) / 2;
                offsetY = 0;
            } else {
                drawWidth = canvas_width;
                drawHeight = img.height * (canvas_width / img.width);
                offsetX = 0;
                offsetY = (canvas_height - drawHeight) / 2;
            }
            
            // Enhanced rendering for high quality
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            ctx.clearRect(0, 0, canvas_width, canvas_height);
            ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);
        }

        const resizeCanvas = () => {
            // Fixed canvas sizing for full screen and high DPI
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            
            canvas.width = window.innerWidth * 2; // High resolution
            canvas.height = window.innerHeight * 2; // High resolution
            
            // Scale the context for high DPI
            context.scale(2, 2);
            
            if (imageCache.has(currentFrameIndex)) {
                const img = imageCache.get(currentFrameIndex);
                drawImageCovered(img, context, canvas.width, canvas.height);
            }
        };

        window.addEventListener('resize', resizeCanvas);

        let scrollVelocity = 0;
        const inertiaFactor = 3;

        let lastKnownScrollPosition = 0;
        let ticking = false;

        const topBar = document.getElementById('topBar');
        let lastScrollPosition = 0;

        const updateScrollAnimation = () => {
            const currentScrollPosition = window.scrollY;
            if (currentScrollPosition !== lastScrollPosition) {
                const maxScrollTop = html.scrollHeight - window.innerHeight;
                const scrollFraction = currentScrollPosition / maxScrollTop;
                const frameIndex = Math.min(frameCount - 1, Math.floor(scrollFraction * frameCount));
                
                if (frameIndex + 1 !== currentFrameIndex) {
                    updateImage(frameIndex + 1);
                }
                
                // Fade out overlay and handle blur effect
                const overlay = document.getElementById('overlay');
                overlay.style.opacity = Math.max(0, 1 - scrollFraction * (frameCount / 17));
                
                if (frameIndex >= 17) {
                    topBar.classList.add('blur');
                } else {
                    topBar.classList.remove('blur');
                }
                
                // Handle end message
                if (currentScrollPosition >= maxScrollTop) {
                    document.getElementById('endMessage').style.display = 'block';
                } else {
                    document.getElementById('endMessage').style.display = 'none';
                }
                
                lastScrollPosition = currentScrollPosition;
            }
            ticking = false;
        };

        const handleScroll = () => {
            if (!ticking) {
                requestAnimationFrame(updateScrollAnimation);
                ticking = true;
            }
        };

        window.addEventListener('scroll', handleScroll, { passive: true });

        // Initial setup
        resizeCanvas();
        startImageLoading(); // Use the new loading method
        
        console.log('Script completed');
    </script>
</body>
</html>